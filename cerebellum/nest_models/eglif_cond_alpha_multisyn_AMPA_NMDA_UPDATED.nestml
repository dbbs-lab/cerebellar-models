"""
eglif_cond_alpha_multisyn - Conductance based extended generalized leaky integrate and fire neuron model
########################################################################################################

Description
+++++++++++

eglif_cond_alpha_multisyn is the generalized leaky integrate and fire neuron according to
Geminiani et al. (2018) [#geminiani_2018]_, with post-synaptic conductances in the form of a
bi-exponential ("alpha") function.

The membrane potential is given by the following differential equation:

.. math::
   \begin{cases}
       C_m \dfrac{dV_m}{dt} = \dfrac{C_m}{\tau_m}(V_m-E_L)
                                - I_{adap} + I_{dep} + I_e + I_{stim} + I_{syn}\\
       \dfrac{dI_{adap}}{dt}=k_{adap}(V_m-E_L)-k_2 \cdot I_{adap}\\
       \dfrac{dI_{dep}}{dt} =-k_1 \cdot I_{dep}\\
   \end{cases}

where the synaptic current :math:`I_{syn}` integrates the input from 4 postsynaptic receptors:

.. math::
       I_{syn} = \sum_{i=1} ^{4} g_i (V - E_{rev,i})

Here, the synapse `i` is excitatory or inhibitory depending on the value of :math:`E_{rev,i}`.

Neuron produces spikes stochastically according to a point process with the firing intensity:

.. math::
  \lambda = \lambda_0 \cdot e^{\dfrac{V_m -V_{th}}{\tau_V}}

In case of spike emission, the spike-triggered adaptation currents :math:`I_{adap}` and
:math:`I_{dep}` are respectively increased and set by their respective constant
(which can be positive or negative):

.. math::
   V_m &= V_{reset}\\
   I_{dep} &= A1\\
   I_{adap} &= I_{adap} + A2

References
++++++++++

.. start-references
A
.. [#geminiani_2018] Geminiani, A., Casellato, C., Locatelli, F., Prestori, F., Pedrocchi, A.,
   & D'Angelo, E. (2018). Complex dynamics in simplified neuronal models:
   reproducing Golgi cell electroresponsiveness. Frontiers in neuroinformatics, 12, 88.
   https://doi.org/10.3389/fninf.2018.00088


See also
++++++++

aeif_cond_alpha, aeif_cond_exp
"""

neuron eglif_cond_alpha_multisyn3:
    state:
        V_m mV = -40.0 mV                   # Membrane potential in mV
        V_m_2 mV = 0.0 mV
        I_dep pA = 0 * pA                   # Depolarizing spike-triggered current
        I_adap pA = 0 * pA                  # Adaptation current
        r integer = 0                       # Refractory state
        g_AMPA_d1 real = 0
        g_AMPA_d2 real = 0
        g_NMDA_d1 real = 0
        g_NMDA_d2 real = 0
        g_NMDA real = 0
        g_GABAA real = 0
        g_GABAB real = 0
        g_AMPA_r2 real = AMPA_g_peak
        g_AMPA_r1 real = AMPA_g_peak  # we tuned with k factor not with function from https://github.com/nest/nestml/blob/master/models/neurons/hill_tononi_neuron.nestml because single exp
        g_NMDA_r1 real = NMDA_g_peak  # we tuned with k factor not with function from https://github.com/nest/nestml/blob/master/models/neurons/hill_tononi_neuron.nestml because single exp
        g_NMDA_r2 real = NMDA_g_peak
        g_GABAA$ real = GABA_A_g_peak

    equations:

        # exponential kernels for the postsynaptic receptor

        kernel g_AMPA_d1' = g_AMPA_r1 * AMPA_A_d1  - (g_AMPA_d1/ AMPA_Tau_d1),
               g_AMPA_r1' =  AMPA_A_r * (-g_AMPA_r1 / AMPA_Tau_r)

        kernel g_AMPA_d2' = g_AMPA_r2 * AMPA_A_d2  - (g_AMPA_d2/ AMPA_Tau_d2),
               g_AMPA_r2' =  AMPA_A_r * (-g_AMPA_r2 / AMPA_Tau_r)

        kernel g_NMDA_d1' =  g_NMDA_r1 * NMDA_A1_decay1 - (g_NMDA_d1 / NMDA_Tau_decay1),
               g_NMDA_r1' = NMDA_A_rise * (-g_NMDA_r1 / NMDA_Tau_rise)

        kernel g_NMDA_d2' =  g_NMDA_r2 * NMDA_A2_decay2 - (g_NMDA_d2 / NMDA_Tau_decay2),
               g_NMDA_r2' = NMDA_A_rise * (-g_NMDA_r2 / NMDA_Tau_rise)

        kernel g_GABAA' = g_GABAA$ - g_GABAA / GABA_A_Tau_2,
               g_GABAA$' = -g_GABAA$ / GABA_A_Tau_1

        # Recordable Magnesium block output

        recordable inline Mg_block real = 0.04 # 1 / (1 + exp((NMDA_Vact - V_m_2) / NMDA_Sact))


        # Update synaptic current

        recordable inline I_syn_ampa pA = -(convolve(g_AMPA_d1, AMPA) + convolve(g_AMPA_d2, AMPA)) * nS * (V_m - AMPA_E_rev)
        recordable inline I_syn_nmda pA = -(convolve(g_NMDA_d1, NMDA) + convolve(g_NMDA_d2, NMDA))* nS * (V_m  - NMDA_E_rev) * Mg_block * NMDA_block * MG_block_scaling_clamp
        recordable inline I_syn_gaba_a pA = -convolve(g_GABAA, GABA_A) * nS * (V_m - GABA_A_E_rev)
        recordable inline I_syn pA =  I_syn_ampa + I_syn_nmda + I_syn_gaba_a

        # Update membrane potential, adaptation and spike triggered currents
        # WARNING: SIGN BELOW IS INCORRECT FOR A LIF MODEL -> Should be V_m' = - (V_m - E_L) / tau_m + ...
        V_m' = (V_m - E_L) / tau_m + (I_e + I_stim - I_adap + I_dep + I_syn) / C_m
        I_dep' = - I_dep * k_1 / ms
        I_adap' = (V_m - E_L) * (k_adap * nS / ms) - I_adap * (k_2 / ms)

    parameters:

        C_m pF = 281.0 pF            # Membrane Capacitance
        tau_m ms = 30.0 ms           # Membrane time constant
        E_L mV = -70.6 mV            # Leak reversal Potential (aka resting potential)
        t_ref ms = 0.0 ms            # Refractory period
        I_e pA = 0 pA                # Constant endogenous current
        V_min mV = -150.0 mV         # Minimal membrane potential value
        V_min_nmda mV = -40 mV       # Minimal membrane potential value NMDA
        V_max_nmda mV = 40 mV        # Maxmium membrane potential value NMDA
        I_AMPA pA = 10 pA
        V_th mV = -50.4 mV           # Spike Threshold
        lambda_0 real = 0.001 / ms

        AMPA_g_peak nS = 0.4025071911 nS
        AMPA_g_scaling nS = 1.2 * 1 * 1.4 nS
        AMPA_E_rev mV = 0.0 mV   # reversal potential
        AMPA_A_r real = 0.016880774981067756 * AMPA_g_scaling
        AMPA_Tau_r ms = 0.35863884707513854 ms
        AMPA_A_d1 real = 0.002547827236535141 * AMPA_g_scaling
        AMPA_A_d2 real = 0.006991204522455618 * AMPA_g_scaling
        AMPA_Tau_d1 ms = 0.3397839945982897 ms
        AMPA_Tau_d2 ms =  3.7435528414523125 ms


        MG_block_scaling_clamp real = 0.46161414343735935
        NMDA_g_scaling real = 18.8 * 1 * 1.4
        NMDA_g_peak nS = 0.04621744018494022 nS # peak conductance
        NMDA_E_rev mV = -3.7 mV  # reversal potential
        NMDA_Tau_rise ms = 14.648 ms
        NMDA_A_rise real = 0.00017425244405793106  * NMDA_g_scaling
        NMDA_A1_decay1 real = 7.06597147410452e-05 * NMDA_g_scaling
        NMDA_A2_decay2 real = 6.062937306724449e-06 * NMDA_g_scaling
        NMDA_Tau_decay1 ms = 21.250 ms
        NMDA_Tau_decay2 ms = 128.771 ms
        NMDA_Vact mV = -20.0 mV      # inactive for V << Vact, inflection of sigmoid
        NMDA_Sact mV = 13 mV        # scale of inactivation
        NMDA_block real = 0
        MGBlock_SpikeInstant mV = 20 mV


        GABA_A_g_peak nS = 0.33 nS   # peak conductance
        GABA_A_Tau_1 ms = 1.0 ms     # rise timecompute_synapse_constant
        GABA_A_Tau_2 ms = 7.0 ms     # decay time, Tau_1 < Tau_2
        GABA_A_E_rev mV = -70.0 mV   # reversal potentiaMGBlock_SpikeInstantlscape rate parameter
        tau_V mV = 0.5 mV            # Escape rate parameter
        V_reset mV = -60.0 mV        # Reset potential

        k_1 real = pow(144.0, -1) / ms      # Decay rate
        k_2 real = pow(80.5, -1) / ms       # Adaptation constant
        k_adap real = 4 * nS / ms           # Adaptation constant
        A1 pA = 100.0 pA                    # Current update constant
        A2 pA = 100.0 pA                    # Current update constant

    internals:
        RefractoryCounts integer = steps(t_ref) # refractory time in steps


    input:

        AMPA <- spike
        NMDA <- spike
        GABA_A <- spike
        I_stim pA <- continuous         # external stimulation current

    output:
        spike

    update:

        V_m = max(V_m, V_min)
        V_m_2 = V_m
        integrate_odes()



        if r > 0:
            r -= 1
            V_m = V_reset
            V_m_2 = MGBlock_SpikeInstant
        else:
            inline lambda real = lambda_0 * exp((V_m - V_th) / tau_V)
            if random_uniform(0, 1) < - expm1(-lambda * resolution()):
                r = RefractoryCounts
                I_dep = A1
                I_adap += A2
                V_m = V_reset
                V_m_2 = MGBlock_SpikeInstant
                emit_spike()